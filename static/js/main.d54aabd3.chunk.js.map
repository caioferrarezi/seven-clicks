{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["findTerms","clearTerm","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","firstTerm","lastTerm","resultMessage","listOfTerms","handleInputChange","bind","assertThisInitialized","handleSubmit","e","value","target","name","setState","defineProperty","preventDefault","loopWiki","term","i","goWiki","then","console","log","_this2","url","fetch","response","json","terms","links","_this3","push","link","searchTerm","replace","data","query","pages","content","keys","_this4","revision","revisions","title","regex","RegExp","vTerms","match","length","concat","newTerm","Math","floor","random","react_default","a","createElement","className","onSubmit","onChange","type","autoComplete","map","item","key","href","Component","Boolean","window","location","hostname","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d54aabd3.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nconst searchURL = 'https://en.wikipedia.org/w/api.php?action=opensearch&origin=*&format=json&search=';\nconst contentURL = 'https://en.wikipedia.org/w/api.php?action=query&origin=*&prop=revisions&rvprop=content&format=json&titles=';\nconst findTerms = /\\[\\[\\w.[^|]+?\\]\\]/gi;\nconst clearTerm = /\\[|\\]|\\w+:/g;\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      firstTerm: '',\n      lastTerm: '',\n      resultMessage: 'The result of your search will appear here',\n      listOfTerms: [],\n    }\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleInputChange(e) {\n    const value = e.target.value\n    const name = e.target.name;\n\n    this.setState({\n      [name]: value,\n    })\n  }\n\n  handleSubmit(e) {\n    e.preventDefault();\n\n    this.setState({\n      listOfTerms: [],\n    })\n\n    if (this.state.firstTerm)\n      this.loopWiki(this.state.firstTerm, 0);\n  }\n\n  async loopWiki(term, i) {\n    if (i < 7) await this.goWiki(term).then(term => {\n      console.log(term, i);\n      if (term) this.loopWiki(term, i + 1);\n    });\n  }\n\n  async searchTerm(term) {\n    if (term) {\n      let url = searchURL + term;\n      //let newTerm;\n    \n      return fetch(url)\n        .then(response => response.json())\n        .then(response => {\n          let terms = response[1];\n          let links = response[3];\n\n          // if we want to get some random term in the array, we can do:\n          //let randomIndex = Math.floor(Math.random() * terms.length);\n          //newTerm = terms[randomIndex];\n          if (terms[0]) {\n            this.setState(state => {\n              state.listOfTerms.push({\n                term: terms[0],\n                link: links[0],\n              });\n            })\n            return terms[0]\n          } else {\n            return null;\n          }\n        })\n    }\n  }\n\n  async goWiki(term) {\n    term = await this.searchTerm(term);\n\n    if (term) {\n      let url = contentURL + term.replace(' ', '_');\n\n      return fetch(url)\n        .then(response => response.json())\n        .then(response => {\n          let data = response.query.pages;\n          let content = data[Object.keys(data)[0]];\n\n          if (this.state.lastTerm) {\n            let revision = content.revisions[0]['*'];\n            let title = content.title;\n            let regex = new RegExp(this.state.lastTerm, 'gi');\n\n            let vTerms = revision.match(regex) || [];\n\n            if (vTerms.length > 0) {\n              this.setState({\n                resultMessage: `We've found the term '${vTerms[0]}' ${vTerms.length} times in the ${title}'s content`,\n              });\n\n              return false;\n            }\n            else {\n              vTerms = revision.match(findTerms)\n              let randomIndex = Math.floor(Math.random() * vTerms.length);\n              let newTerm = vTerms[randomIndex].replace(clearTerm, '');\n\n              this.setState({\n                resultMessage: 'We\\'re so sorry, but our search didn\\'t find anything ):',\n              });\n\n              return newTerm;\n            }\n          }\n        });\n    } else {\n      this.setState({\n        resultMessage: 'We\\'ve reached out our possibilities, so sorry ):'\n      });\n      return null;\n    }\n  }\n\n  render() {\n    const listOfTerms = this.state.listOfTerms;\n\n    return (\n      <div className=\"s-app\">\n        <header className=\"o-header\">\n          <div className=\"o-header__title\">\n            <h1>Result</h1>\n            <p>{this.state.resultMessage}</p>\n          </div>\n\n          <form className=\"o-form\" onSubmit={this.handleSubmit}>\n            <label>Initial Term\n              <input \n                value={this.state.firstTerm}\n                onChange={this.handleInputChange}\n                name=\"firstTerm\" \n                type=\"text\"\n                autoComplete=\"off\"\n                className=\"o-form__input\" />\n            </label>\n            \n            <label>Last Term\n              <input \n                value={this.state.lastTerm}\n                onChange={this.handleInputChange}\n                name=\"lastTerm\" \n                type=\"text\"\n                autoComplete=\"off\"\n                className=\"o-form__input\" />\n            </label>\n\n            <button \n              type=\"submit\"\n              className=\"o-form__button\">Search</button>\n          </form>\n        </header>\n\n        <main className=\"o-result\">\n          {listOfTerms.length > 0 &&\n            <ol className=\"o-result__list\">{\n              listOfTerms.map((item, i) => {\n                return <li key={i}>\n                  {item.term}\n                  <a href={item.link} target=\"_blank\">view full article &rarr;</a>\n                </li>\n              })\n            }</ol>\n          }\n        </main>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}